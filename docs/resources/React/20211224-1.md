## 클로저란

```js
function outer() {
  const value = 100;

  console.log(value);
}
outer(); // 100

console.log(value); // Error: not defined
```

위와 같이, `outer`라는 함수가 정의되어 있다. 이 함수 내부에는 `value`라는 변수가 선언되어 있고, `console.log`함수로 해당 값을 콘솔에 출력하고 있다.

`value`함수는 기본적으로, `outer`함수의 실행이 끝나면 해당 참조를 잃게 되어 자바스크립트의 가비지 컬렉터에 의해 회수된다.

```js
function outer() {
  const value = 100;

  function inner() {
    console.log(value);
  }

  return inner;
}

const func = outer();
func(); // 100
```

이렇게 `outer`함수의 `value`변수를 참조하는 `inner` 내부함수를 선언하고, 그 함수 자체를 반환받으면 코드 아래와 같이 이미 실행이 끝난 `outer`변수의 내부 변수에 접근하는 함수를 얻을 수 있다.

실제로 LifeCycle이 끝난 함수의 내부값에 접근할 수 있게 되는 이러한 상황을 `클로저`라고 하고, 여기서의 `inner` 함수를 클로저 함수라고 한다.

위와 같은 방식을 이용하면, `value` 변수의 값이 변할 우려가 없는 진정한 상수 데이터가 될 수 있다. 또한 `inner` 함수의 정의에 따라서, `value` 변수에 접근할 때 특정한 절차를 반드시 따르도록 할 수 있다. 그리고 그렇게 한 것이 React의 `useState`라고 볼 수 있다.

## 클로저와 useState

React의 함수형 컴포넌트에서는 `useState` 함수를 통해 state를 생성할 수 있다. 그리고 이 state는 `useState`에서 반환되는 함수를 통해서만 값을 변경해서 사용한다.

```js
const [value, setValue] = useState(0);
```

`value`의 값을 바꾸고 싶을 땐, `setValue` 함수를 사용해야만 한다. 그래야만 React의 라이프사이클이 올바르게 작동하여, state의 변경이 컴포넌트에 적용되기 때문이다. 값에 접근할 때 "특정한 절차"를 따르도록 한다는 점이 위에서 설명한 클로저와 닮았다.

```js
const useState = (initState) => {
  let state = initState;

  const setState = (newState) => {
    state = newState;
    // React LifeCycle 관련 수행
  };

  return [state, setState];
};
```

실제와는 다르겠지만, `useState`도 클로저를 이용하여 구현되어 있다고 한다. 그래서 `state`와, `setState`를 구분하여 반환하고, `setState`를 이용해야만 라이프사이클이 정상적으로 수행되면서 값을 제어할 수가 있다.
